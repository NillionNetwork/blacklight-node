//! # Error Handling for Solidity Revert Data
//!
//! This module provides type-safe decoding of Solidity revert data using the Alloy library.
//! When a smart contract transaction fails (reverts), the EVM returns encoded error data.
//! This module decodes that raw hex data into human-readable error messages.
//!
//! ## Supported Error Types
//!
//! 1. **Standard `Error(string)`** - From `require(condition, "message")` statements
//!    - Selector: `0x08c379a0`
//!    - Most common error type in Solidity contracts
//!
//! 2. **Standard `Panic(uint256)`** - From `assert()` failures and arithmetic errors
//!    - Selector: `0x4e487b71`
//!    - Includes overflow, division by zero, array bounds, etc.
//!
//! 3. **Custom Contract Errors** - Gas-efficient custom errors from contract ABIs
//!    - Currently supports: `StakingOperatorsErrors`, we need to add more for the custom contracts such as HeartbeatManagerErrors
//!    - Each error has a unique 4-byte selector derived from its signature
//!
//! ## Usage Flow
//!
//! ```text
//! Transaction reverts → RPC returns error with hex data →
//!     decode_any_error() → try_extract_from_string() → decode_revert() →
//!         → "blacklight: HTX already exists" (human-readable!)
//! ```
//!
//! ## Example
//!
//! Instead of seeing:
//! ```text
//! error: execution reverted: 0x08c379a0000000...
//! ```
//!
//! You now see:
//! ```text
//! error: blacklight: HTX already exists
//! ```
//!
//! ## Main Entry Points
//!
//! - [`decode_any_error`] - Generic entry point for any error type
//! - [`extract_revert_from_contract_error`] - For Alloy's `ContractError` type
//! - [`decode_revert`] - For raw `Bytes` revert data

use alloy::{
    contract::Error as ContractError, primitives::Bytes, sol, sol_types::SolInterface,
    transports::TransportError,
};

// ============================================================================
// Standard Solidity Errors
// ============================================================================
//
// The `sol!` macro generates Rust types that can decode ABI-encoded error data.
// Each error has a unique 4-byte "selector" (first 4 bytes of keccak256(signature))
// that identifies it in the raw revert data.

sol! {
    /// Standard Solidity errors used by the EVM.
    ///
    /// - `Error(string)` - Produced by `require(condition, "message")` when condition is false
    ///   Selector: `0x08c379a0` = keccak256("Error(string)")[:4]
    ///
    /// - `Panic(uint256)` - Produced by `assert()` failures, arithmetic errors, etc.
    ///   Selector: `0x4e487b71` = keccak256("Panic(uint256)")[:4]
    #[derive(Debug, PartialEq, Eq)]
    library StandardErrors {
        error Error(string message);
        error Panic(uint256 code);
    }
}

// ============================================================================
// Contract-specific Errors - Extracted from ABIs
// ============================================================================
//
// Custom Solidity errors are more gas-efficient than `require()` with strings.
// The `sol!` macro in the contract binding modules automatically generates
// Rust types for all custom errors defined in the contract ABI.
//
// To add support for a new contract's errors:
// 1. Ensure the contract module uses `sol!` to generate bindings
// 2. Re-export the errors enum here: `pub use super::module::Contract::ContractErrors;`
// 3. Add a case in `decode_revert()` to try decoding with the new error type
// 4. Add a `format_X_error()` function to provide human-readable messages

/// Re-export StakingOperators custom errors from the contract bindings.
/// These are automatically generated by the `sol!` macro from the contract ABI.
pub use crate::contract_client::staking_operators::StakingOperators::StakingOperatorsErrors;

// Note: HeartbeatManager currently uses require() with string messages, not custom errors.
// When custom errors are added to the contract, they will be automatically available
// via HeartbeatManager::HeartbeatManagerErrors and should be added here.

// ============================================================================
// DecodedRevert Enum - The Result of Decoding
// ============================================================================

/// Represents the result of decoding Solidity revert data.
///
/// This enum captures all possible outcomes when attempting to decode raw revert bytes:
///
/// | Variant | When it's used |
/// |---------|----------------|
/// | `ErrorString` | `require()` failed with a message |
/// | `Panic` | `assert()` failed or arithmetic error |
/// | `StakingError` | Custom error from StakingOperators contract |
/// | `RawRevert` | We got hex data but couldn't decode it |
/// | `NoRevertData` | No revert data at all (unusual) |
#[derive(Debug, Clone)]
pub enum DecodedRevert {
    /// Standard `Error(string)` from `require(condition, "message")` statements.
    /// This is the most common error type in Solidity contracts.
    ErrorString(String),

    /// Panic error with a numeric panic code.
    /// Produced by `assert()` failures, arithmetic overflow, division by zero, etc.
    /// See [`panic_reason`] for code meanings.
    Panic(u64),

    /// Custom error from the StakingOperators contract.
    /// These are gas-efficient errors defined in the contract's ABI.
    StakingError(String),

    /// Raw revert data that couldn't be decoded by any known error type.
    /// Contains the hex bytes so the user can manually debug.
    RawRevert(Bytes),

    /// No revert data was available in the error.
    /// This is unexpected for contract reverts - includes context about why.
    NoRevertData(String),
}

impl std::fmt::Display for DecodedRevert {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DecodedRevert::ErrorString(msg) => write!(f, "{}", msg),
            DecodedRevert::Panic(code) => write!(f, "Panic({}): {}", code, panic_reason(*code)),
            DecodedRevert::StakingError(msg) => write!(f, "{}", msg),
            DecodedRevert::RawRevert(data) => write!(f, "Raw revert data: {}", data),
            DecodedRevert::NoRevertData(details) => write!(f, "No revert data ({})", details),
        }
    }
}

// ============================================================================
// Panic Code Meanings
// ============================================================================

/// Get human-readable reason for Solidity panic codes.
///
/// Panic codes are defined in the Solidity documentation:
/// <https://docs.soliditylang.org/en/latest/control-structures.html#panic-via-assert-and-error-via-require>
///
/// # Panic Codes
///
/// | Code | Meaning |
/// |------|---------|
/// | 0x00 | Generic compiler panic |
/// | 0x01 | `assert()` failure |
/// | 0x11 | Arithmetic overflow/underflow |
/// | 0x12 | Division by zero |
/// | 0x21 | Invalid enum value |
/// | 0x22 | Storage byte array encoding error |
/// | 0x31 | `pop()` on empty array |
/// | 0x32 | Array index out of bounds |
/// | 0x41 | Memory allocation overflow |
/// | 0x51 | Zero-initialized function pointer call |
fn panic_reason(code: u64) -> &'static str {
    match code {
        0x00 => "generic compiler panic",
        0x01 => "assertion failed",
        0x11 => "arithmetic overflow/underflow",
        0x12 => "division by zero",
        0x21 => "invalid enum value",
        0x22 => "storage byte array encoding error",
        0x31 => "pop on empty array",
        0x32 => "array index out of bounds",
        0x41 => "memory allocation overflow",
        0x51 => "zero-initialized function pointer call",
        _ => "unknown panic code",
    }
}

// ============================================================================
// Core Decoding Logic
// ============================================================================

/// Decode raw revert data bytes into a human-readable error.
///
/// This function attempts to decode the raw bytes in the following order:
/// 1. **Standard `Error(string)`** - Most common from `require()`
/// 2. **Standard `Panic(uint256)`** - From `assert()` or overflow
/// 3. **Custom `StakingOperatorsErrors`** - Contract-specific errors
/// 4. **Fallback** - Return the raw hex so user can debug
///
/// # Arguments
///
/// * `data` - Raw ABI-encoded revert data from the EVM
///
/// # Returns
///
/// A [`DecodedRevert`] variant representing the decoded error.
///
/// # Example
///
/// ```ignore
/// let revert_data = Bytes::from(hex::decode("08c379a0...").unwrap());
/// let decoded = decode_revert(&revert_data);
/// println!("Error: {}", decoded); // "blacklight: HTX already exists"
/// ```
pub fn decode_revert(data: &Bytes) -> DecodedRevert {
    // Empty revert data is unusual - contracts normally include some data
    if data.is_empty() {
        return DecodedRevert::NoRevertData("empty revert data".to_string());
    }

    // Step 1: Try to decode as standard Error(string) or Panic(uint256)
    // The abi_decode method checks the 4-byte selector and decodes the rest
    if let Ok(err) = StandardErrors::StandardErrorsErrors::abi_decode(data) {
        match err {
            StandardErrors::StandardErrorsErrors::Error(e) => {
                return DecodedRevert::ErrorString(e.message);
            }
            StandardErrors::StandardErrorsErrors::Panic(p) => {
                // Panic code is a uint256, but we only care about the low bits
                return DecodedRevert::Panic(p.code.try_into().unwrap_or(0));
            }
        }
    }

    // Step 2: Try to decode as StakingOperators custom errors
    // Each custom error has a unique 4-byte selector derived from its signature
    if let Ok(err) = StakingOperatorsErrors::abi_decode(data) {
        let msg = format_staking_error(&err);
        return DecodedRevert::StakingError(msg);
    }

    // Step 3: Unknown error - return raw bytes so user can debug
    // This allows users to manually decode or report the unknown error type
    DecodedRevert::RawRevert(data.clone())
}

// ============================================================================
// Human-Readable Error Formatting
// ============================================================================

/// Format a StakingOperators custom error into a human-readable message.
///
/// This function provides user-friendly descriptions for each custom error
/// defined in the StakingOperators contract.
///
/// # Arguments
///
/// * `err` - The decoded StakingOperators error variant
///
/// # Returns
///
/// A human-readable error message string.
fn format_staking_error(err: &StakingOperatorsErrors) -> String {
    match err {
        StakingOperatorsErrors::DifferentStaker(_) => "Different staker".to_string(),
        StakingOperatorsErrors::InsufficientStake(_) => "Insufficient stake".to_string(),
        StakingOperatorsErrors::NoStake(_) => "No stake".to_string(),
        StakingOperatorsErrors::NoUnbonding(_) => "No unbonding request".to_string(),
        StakingOperatorsErrors::NotActive(_) => "Operator not active".to_string(),
        StakingOperatorsErrors::NotReady(_) => "Unbonding period not ready".to_string(),
        StakingOperatorsErrors::NotStaker(_) => "Not a staker".to_string(),
        StakingOperatorsErrors::OperatorJailed(_) => "Operator is jailed".to_string(),
        StakingOperatorsErrors::PendingUnbonding(_) => "Pending unbonding exists".to_string(),
        StakingOperatorsErrors::UnbondingExists(_) => "Unbonding already exists".to_string(),
        StakingOperatorsErrors::ZeroAddress(_) => "Zero address not allowed".to_string(),
        StakingOperatorsErrors::ZeroAmount(_) => "Zero amount not allowed".to_string(),
    }
}

// ============================================================================
// Alloy ContractError Extraction
// ============================================================================
//
// Alloy wraps errors in ContractError, which contains TransportError for RPC errors.
// The revert data is often buried in the TransportError's ErrorResp data field.
// This section extracts that data properly instead of relying on string parsing.

/// Extract and decode revert data from an Alloy [`ContractError`].
///
/// This is the **proper** way to get revert data from Alloy errors - it accesses
/// the structured error fields directly rather than parsing strings.
///
/// # How It Works
///
/// 1. For `TransportError`: Extracts hex data from the RPC error response
/// 2. For `AbiError`: Returns the ABI encoding error (rare)
/// 3. For other types: Falls back to parsing the Debug representation
///
/// # Arguments
///
/// * `error` - The Alloy contract error to extract revert data from
///
/// # Returns
///
/// A [`DecodedRevert`] with the decoded error or context about why decoding failed.
pub fn extract_revert_from_contract_error(error: &ContractError) -> DecodedRevert {
    match error {
        // TransportError is the most common - it wraps RPC error responses
        ContractError::TransportError(transport_err) => {
            extract_revert_from_transport_error(transport_err)
        }
        // ABI errors happen when encoding/decoding fails (rare)
        ContractError::AbiError(abi_err) => {
            DecodedRevert::NoRevertData(format!("ABI error: {}", abi_err))
        }
        // For other error types, try to extract from the Debug representation
        // This is a fallback - ideally we'd handle all variants explicitly
        _ => {
            let debug_str = format!("{:?}", error);
            if let Some(decoded) = try_extract_from_string(&debug_str) {
                decoded
            } else {
                DecodedRevert::NoRevertData(format!("Unknown error type: {}", error))
            }
        }
    }
}

/// Extract revert data from an Alloy [`TransportError`].
///
/// The RPC response for a reverted transaction typically includes:
/// - `ErrorResp.data`: Hex-encoded revert data (what we want)
/// - `ErrorResp.message`: Human-readable error message from the RPC node
///
/// # Arguments
///
/// * `error` - The transport error from the RPC layer
///
/// # Returns
///
/// A [`DecodedRevert`] with the decoded error data.
fn extract_revert_from_transport_error(error: &TransportError) -> DecodedRevert {
    match error {
        TransportError::ErrorResp(err_resp) => {
            // The error response may contain revert data in the `data` field
            if let Some(data) = &err_resp.data {
                // Get the raw JSON value as a string
                let data_str = data.get();
                // Remove JSON quotes if present (RPC returns "0x..." as a JSON string)
                let data_str = data_str.trim_matches('"');

                // Try to parse as hex string starting with 0x
                if let Some(hex_data) = data_str.strip_prefix("0x") {
                    if let Ok(bytes) = hex::decode(hex_data) {
                        return decode_revert(&Bytes::from(bytes));
                    }
                }
                // If not hex, include the raw data for debugging
                return DecodedRevert::NoRevertData(format!("Error data: {}", data_str));
            }
            // No data field, but we have the RPC error message
            DecodedRevert::NoRevertData(format!("RPC error: {}", err_resp.message))
        }
        // For other transport errors (timeout, connection, etc.), try string extraction
        _ => {
            let err_str = error.to_string();
            if let Some(decoded) = try_extract_from_string(&err_str) {
                decoded
            } else {
                DecodedRevert::NoRevertData(format!("Transport error: {}", err_str))
            }
        }
    }
}

// ============================================================================
// String Pattern Extraction (Fallback)
// ============================================================================
//
// Different RPC providers format error messages differently. This fallback
// searches the error string for hex patterns that might contain revert data.
// This is less reliable than structured extraction but catches edge cases.

/// Try to extract revert data from an error string (fallback mechanism).
///
/// Different RPC providers format errors differently:
/// - `execution reverted: 0x08c379a0...`
/// - `reverted with data: 0x...`
/// - `data: 0x...`
///
/// This function searches for these patterns and extracts the hex data.
///
/// # Arguments
///
/// * `error_str` - The error message string to search
///
/// # Returns
///
/// `Some(DecodedRevert)` if hex data was found and decoded, `None` otherwise.
fn try_extract_from_string(error_str: &str) -> Option<DecodedRevert> {
    // Patterns that indicate hex revert data follows
    const PATTERNS: &[&str] = &[
        "execution reverted: 0x",
        "reverted with data: 0x",
        "revert data: 0x",
        "data: 0x",
        "0x08c379a0", // Error(string) selector - direct match
        "0x4e487b71", // Panic(uint256) selector - direct match
    ];

    for pattern in PATTERNS {
        if let Some(start) = error_str.find(pattern) {
            // Calculate where the hex data starts
            let hex_start = if pattern.ends_with("0x") {
                start + pattern.len() - 2 // Include the 0x prefix
            } else {
                start // Pattern IS the start of hex data
            };

            let remaining = &error_str[hex_start..];

            // Find the end of the hex string (only hex chars after 0x)
            let hex_end = if remaining.starts_with("0x") {
                2 + remaining
                    .strip_prefix("0x")
                    .unwrap_or(remaining)
                    .chars()
                    .take_while(|c| c.is_ascii_hexdigit())
                    .count()
            } else {
                remaining
                    .chars()
                    .take_while(|c| c.is_ascii_hexdigit())
                    .count()
            };

            let hex_str = &remaining[..hex_end];
            // Need at least 0x + 4 bytes (8 hex chars) for a valid selector
            if hex_str.len() >= 10 {
                let without_prefix = hex_str.strip_prefix("0x").unwrap_or(hex_str);
                if let Ok(bytes) = hex::decode(without_prefix) {
                    return Some(decode_revert(&Bytes::from(bytes)));
                }
            }
        }
    }

    // Special case: plain text error message after "execution reverted:"
    // Some RPC providers return: `execution reverted: blacklight: HTX already exists`
    if error_str.contains("execution reverted") {
        if let Some(idx) = error_str.find("execution reverted:") {
            let after = &error_str[idx + 19..]; // Skip "execution reverted:"
            let msg = after.trim().trim_matches('"').trim();
            // Only use if it's not hex data (already handled above)
            if !msg.is_empty() && !msg.starts_with("0x") {
                return Some(DecodedRevert::ErrorString(msg.to_string()));
            }
        }
    }

    None
}

// ============================================================================
// Generic Entry Points
// ============================================================================

/// Decode ANY error into a human-readable message.
///
/// This is the **main entry point** for error decoding. It accepts any error type
/// that implements `Display` and `Debug`, and tries its best to extract revert data.
///
/// # Strategy
///
/// 1. Try extracting from the `Display` string representation
/// 2. Try extracting from the `Debug` string representation (often has more details)
/// 3. If nothing works, return the raw error so the user can see what's happening
///
/// # Arguments
///
/// * `error` - Any error type implementing `Display` and `Debug`
///
/// # Returns
///
/// A [`DecodedRevert`] - never panics, always returns something useful.
///
/// # Example
///
/// ```ignore
/// let decoded = decode_any_error(&some_error);
/// log::error!("Transaction failed: {}", decoded);
/// ```
pub fn decode_any_error<E: std::fmt::Display + std::fmt::Debug>(error: &E) -> DecodedRevert {
    let error_str = error.to_string();
    let debug_str = format!("{:?}", error);

    // First try the Display representation
    if let Some(decoded) = try_extract_from_string(&error_str) {
        return decoded;
    }

    // Then try the Debug representation (often has more details like struct fields)
    if let Some(decoded) = try_extract_from_string(&debug_str) {
        return decoded;
    }

    // If nothing works, return the error as-is so user can see what's happening
    DecodedRevert::NoRevertData(format!(
        "Could not extract revert data. Raw error: {}",
        error_str
    ))
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    /// Test decoding a standard Error(string) from require() statements.
    ///
    /// ABI encoding format for Error(string):
    /// - Bytes 0-3: Selector (0x08c379a0)
    /// - Bytes 4-35: Offset to string data (always 0x20 = 32)
    /// - Bytes 36-67: String length
    /// - Bytes 68+: UTF-8 string data (padded to 32 bytes)
    #[test]
    fn test_decode_error_string() {
        // "blacklight: unknown HTX" encoded as Error(string)
        // Selector: 08c379a0
        // Offset:   0000...0020 (32 bytes)
        // Length:   0000...0012 (18 bytes = "blacklight: unknown HTX".len())
        // Data:     4e696c41563a20756e6b6e6f776e20485458 + padding
        let data = hex::decode(
            "08c379a0\
             0000000000000000000000000000000000000000000000000000000000000020\
             0000000000000000000000000000000000000000000000000000000000000012\
             4e696c41563a20756e6b6e6f776e204854580000000000000000000000000000",
        )
        .unwrap();

        let decoded = decode_revert(&Bytes::from(data));

        match decoded {
            DecodedRevert::ErrorString(msg) => {
                assert_eq!(msg, "NilAV: unknown HTX");
            }
            _ => panic!("Expected ErrorString, got {:?}", decoded),
        }
    }

    /// Test decoding a Panic(uint256) from assert() failures.
    ///
    /// ABI encoding format for Panic(uint256):
    /// - Bytes 0-3: Selector (0x4e487b71)
    /// - Bytes 4-35: Panic code as uint256
    #[test]
    fn test_decode_panic() {
        // Panic(1) - assert failure
        // Selector: 4e487b71
        // Code:     0000...0001
        let data = hex::decode(
            "4e487b71\
             0000000000000000000000000000000000000000000000000000000000000001",
        )
        .unwrap();

        let decoded = decode_revert(&Bytes::from(data));

        match decoded {
            DecodedRevert::Panic(code) => {
                assert_eq!(code, 1);
            }
            _ => panic!("Expected Panic, got {:?}", decoded),
        }
    }

    /// Test decoding a custom StakingOperators error.
    ///
    /// Custom errors with no parameters only need the 4-byte selector.
    /// Selector for InsufficientStake(): cast sig "InsufficientStake()" = 0xf1bc94d2
    #[test]
    fn test_decode_staking_error() {
        // InsufficientStake() error - selector only, no params
        let data = hex::decode("f1bc94d2").unwrap();

        let decoded = decode_revert(&Bytes::from(data));

        match decoded {
            DecodedRevert::StakingError(msg) => {
                assert_eq!(msg, "Insufficient stake");
            }
            _ => panic!("Expected StakingError, got {:?}", decoded),
        }
    }

    /// Test the Display implementation for all DecodedRevert variants.
    #[test]
    fn test_display() {
        let err = DecodedRevert::ErrorString("test error".to_string());
        assert_eq!(format!("{}", err), "test error");

        let panic = DecodedRevert::Panic(1);
        assert_eq!(format!("{}", panic), "Panic(1): assertion failed");

        let staking = DecodedRevert::StakingError("No stake".to_string());
        assert_eq!(format!("{}", staking), "No stake");
    }

    /// Test extracting revert data from various error string formats.
    #[test]
    fn test_try_extract_from_string() {
        // Test with "execution reverted: 0x..." format (common from geth/anvil)
        let error_msg = "execution reverted: 0x08c379a00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001a4e696c41563a204854582020616c72656164792065786973747300000000000000";
        let decoded = try_extract_from_string(error_msg);
        assert!(decoded.is_some());
        if let Some(DecodedRevert::ErrorString(msg)) = decoded {
            assert!(msg.contains("NilAV"));
        }

        // Test with raw hex selector embedded in string
        let error_msg2 = "some error 0x08c379a0abcdef";
        let decoded2 = try_extract_from_string(error_msg2);
        assert!(decoded2.is_some());
    }

    /// Test that panic_reason returns correct descriptions for known codes.
    #[test]
    fn test_panic_reasons() {
        assert_eq!(panic_reason(0x01), "assertion failed");
        assert_eq!(panic_reason(0x11), "arithmetic overflow/underflow");
        assert_eq!(panic_reason(0x12), "division by zero");
    }
}
